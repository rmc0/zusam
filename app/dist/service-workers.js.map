{"version":3,"sources":["../node_modules/idb-keyval/dist/idb-keyval.mjs","service-workers.js"],"names":["Store","constructor","dbName","storeName","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","_withIDBStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","get","key","req","set","value","put","del","delete","clear","keys","openKeyCursor","openCursor","call","push","continue","ZUSAM_VERSION","CACHE_VERSION","CACHE","cache_store","cached_routes","fromNetwork","request","addToCache","fetch","response","responseClone","clone","caches","cache","fromCache","match","matching","url","lastUsed","Date","now","_","update","self","addEventListener","evt","method","Object","some","r","includes","respondWith","waitUntil","hasOwnProperty","find","catch"],"mappings":"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","file":"service-workers.js","sourceRoot":"../src","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import { Store, set, get } from \"idb-keyval\";\n\nconst ZUSAM_VERSION = \"4.1\";\nconst CACHE_VERSION = \"0.2\";\nconst CACHE = \"zusam-\" + ZUSAM_VERSION + \"-simplecache-\" + CACHE_VERSION;\nconst cache_store = new Store(\"zusam-\" + ZUSAM_VERSION, CACHE);\nconst cached_routes = {\n  \"/api/users/\": 1000 * 60 * 60 * 24, // 24h\n  \"/api/images/crop/\": null,\n  \"/api/images/thumbnail/\": null,\n  \"/api/links/by_url?\": null\n};\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener(\"fetch\", function(evt) {\n  if (evt.request.method == \"GET\") {\n    // cache-update routes: retrieve from cache and update in background\n    if (Object.keys(cached_routes).some(r => evt.request.url.includes(r))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(_ => {\n        get(evt.request.url, cache_store)\n          .then(r => {\n            if (r && r.hasOwnProperty(\"lastUsed\") && r.lastUsed != null) {\n              const timeout =\n                r.lastUsed +\n                cached_routes[\n                  Object.keys(cached_routes).find(r =>\n                    evt.request.url.includes(r)\n                  )\n                ];\n              // update the cache only if the timeout is reached\n              if (timeout < Date.now()) {\n                update(evt.request);\n              }\n            }\n          })\n          .catch(_ => update(evt.request));\n      });\n    } else {\n      // from-network without cache is the default\n      return fromNetwork(evt.request, false);\n    }\n  }\n});\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, addToCache) {\n  return fetch(request).then(response => {\n    if (addToCache) {\n      // response may be used only once\n      // we need to save clone to put one copy in cache\n      // and serve second one\n      let responseClone = response.clone();\n      caches.open(CACHE).then(cache => {\n        addToCache(cache, request, responseClone);\n      });\n    }\n    return response;\n  });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE).then(cache => {\n    return cache.match(request).then(matching => {\n      if (matching) {\n        // reset lastUsed\n        return set(\n          request.url,\n          {\n            lastUsed: Date.now()\n          },\n          cache_store\n        ).then(_ => matching);\n      } else {\n        // if nothing matches, return response from network\n        return fromNetwork(request, true);\n      }\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE).then(cache => {\n    return fetch(request).then(response => {\n      return addToCache(cache, request, response);\n    });\n  });\n}\n\n// Add response to cache and store the lastUsed timestamp at the same time\nfunction addToCache(cache, request, response) {\n  return set(\n    request.url,\n    {\n      lastUsed: Date.now()\n    },\n    cache_store\n  ).then(_ => cache.put(request, response));\n}\n"]}