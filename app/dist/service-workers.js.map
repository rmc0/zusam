{"version":3,"sources":["../node_modules/idb-keyval/dist/idb-keyval.mjs","service-workers.js"],"names":["Store","constructor","dbName","storeName","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","_withIDBStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","get","key","req","set","value","put","del","delete","clear","keys","openKeyCursor","openCursor","call","push","continue","ZUSAM_VERSION","CACHE_VERSION","CACHE","cache_store","cached_routes","route","RegExp","duration","addToCache","cache","request","response","url","lastUsed","Date","now","_","fromNetwork","toCache","fetch","responseClone","clone","caches","fromCache","match","matching","update","self","addEventListener","evt","method","some","r","respondWith","waitUntil","hasOwnProperty","find","catch"],"mappings":"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","file":"service-workers.js","sourceRoot":"../src","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import { Store, set, get } from \"idb-keyval\";\n\nconst ZUSAM_VERSION = \"4.1\";\nconst CACHE_VERSION = \"0.3\";\nconst CACHE = \"zusam-\" + ZUSAM_VERSION + \"-simplecache-\" + CACHE_VERSION;\nconst cache_store = new Store(\"zusam-\" + ZUSAM_VERSION, CACHE);\nconst cached_routes = [\n  {\n    route: new RegExp(\"/api/users/[^/]+/?$\"),\n    duration: 1000 * 60 * 60 * 24, // 24h\n  },\n  {\n    route: new RegExp(\"/api/images/crop/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/images/thumbnail/\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  },\n  {\n    route: new RegExp(\"/api/links/by_url\\?\"),\n    duration: 1000 * 60 * 60 * 24 * 365, // 1 year\n  }\n];\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener(\"fetch\", function(evt) {\n  if (evt.request.method == \"GET\") {\n    // cache-update routes: retrieve from cache and update in background\n    if (cached_routes.some(r => evt.request.url.match(r.route))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(_ => {\n        get(evt.request.url, cache_store)\n          .then(r => {\n            if (r && r.hasOwnProperty(\"lastUsed\") && r.lastUsed != null) {\n              const timeout = r.lastUsed + cached_routes.find(r => evt.request.url.match(r.route))[\"duration\"];\n              // update the cache only if the timeout is reached\n              if (timeout < Date.now()) {\n                update(evt.request);\n              }\n            }\n          })\n          .catch(_ => update(evt.request));\n      });\n    }\n  }\n});\n\n// Add response to cache and store the lastUsed timestamp at the same time\nfunction addToCache(cache, request, response) {\n  return set(\n    request.url,\n    {\n      lastUsed: Date.now()\n    },\n    cache_store\n  ).then(_ => cache.put(request, response));\n}\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, toCache) {\n  return fetch(request).then(response => {\n    if (toCache) {\n      // response may be used only once\n      // we need to save clone to put one copy in cache\n      // and serve second one\n      let responseClone = response.clone();\n      caches.open(CACHE).then(cache => addToCache(cache, request, responseClone));\n    }\n    return response;\n  });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE).then(cache => {\n    return cache.match(request).then(matching => {\n      if (matching) {\n        // reset lastUsed\n        return set(\n          request.url,\n          {\n            lastUsed: Date.now()\n          },\n          cache_store\n        ).then(_ => matching);\n      } else {\n        // if nothing matches, return response from network\n        return fromNetwork(request, true);\n      }\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE).then(cache => {\n    return fetch(request).then(response => {\n      return addToCache(cache, request, response);\n    });\n  });\n}\n"]}