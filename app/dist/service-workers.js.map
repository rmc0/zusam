{"version":3,"sources":["service-workers.js"],"names":["CACHE","isCacheableUrl","url","routes","some","r","includes","fromNetwork","request","addToCache","fetch","then","response","responseClone","clone","caches","open","cache","put","fromCache","match","matching","update","self","addEventListener","evt","method","respondWith","waitUntil"],"mappings":";AAAA,MAAMA,EAAQ,4BAoBd,SAASC,EAAeC,GAKfC,MAJQ,CACb,oBACA,0BAEYC,KAAKC,GAAKH,EAAII,SAASD,IAIvC,SAASE,EAAYC,EAASC,GACnBC,OAAAA,MAAMF,GAASG,KAAK,SAAUC,GAC/BH,GAAAA,EAAY,CAIVI,IAAAA,EAAgBD,EAASE,QAC7BC,OAAOC,KAAKhB,GAAOW,KAAK,SAAUM,GAChCA,EAAMC,IAAIV,EAASK,KAGhBD,OAAAA,IAOb,SAASO,EAAUX,GACVO,OAAAA,OAAOC,KAAKhB,GAAOW,KAAK,SAAUM,GAChCA,OAAAA,EAAMG,MAAMZ,GAASG,KAAK,SAAUU,GAElCA,OAAAA,GAAYd,EAAYC,GAAS,OAO9C,SAASc,EAAOd,GACPO,OAAAA,OAAOC,KAAKhB,GAAOW,KAAK,SAAUM,GAChCP,OAAAA,MAAMF,GAASG,KAAK,SAAUC,GAC5BK,OAAAA,EAAMC,IAAIV,EAASI,OAzDhCW,KAAKC,iBAAiB,QAAS,SAASC,GAClCA,GAAsB,OAAtBA,EAAIjB,QAAQkB,OAAiB,CAC3BzB,IAAAA,EAAewB,EAAIjB,QAAQN,KAQtBK,OAAAA,EAAYkB,EAAIjB,SAAS,GALhCiB,EAAIE,YAAYR,EAAUM,EAAIjB,UAG9BiB,EAAIG,UAAUN,EAAOG,EAAIjB","file":"service-workers.js","sourceRoot":"../src","sourcesContent":["const CACHE = 'zusam-4.1-simplecache-0.2';\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener('fetch', function(evt) {\n  if (evt.request.method == \"GET\") {\n    if (isCacheableUrl(evt.request.url)) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n      // ...and `waitUntil()` to prevent the worker from being killed until the\n      // cache is updated.\n      evt.waitUntil(update(evt.request));\n    } else {\n      return fromNetwork(evt.request, false);\n    }\n  }\n});\n\n// Return true if the url is one we want to cache\nfunction isCacheableUrl(url) {\n  const routes = [\n    '/api/images/crop/',\n    '/api/images/thumbnail/',\n  ];\n  return routes.some(r => url.includes(r));\n}\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, addToCache) {\n    return fetch(request).then(function (response) {\n      if (addToCache) {\n        // response may be used only once\n        // we need to save clone to put one copy in cache\n        // and serve second one\n        let responseClone = response.clone();\n        caches.open(CACHE).then(function (cache) {\n          cache.put(request, responseClone);\n        });\n      }\n      return response;\n    });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE).then(function (cache) {\n    return cache.match(request).then(function (matching) {\n      // if nothing matches, return response from network\n      return matching || fromNetwork(request, true);\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE).then(function (cache) {\n    return fetch(request).then(function (response) {\n      return cache.put(request, response);\n    });\n  });\n}\n"]}