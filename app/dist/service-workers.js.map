{"version":3,"sources":["../node_modules/idb-keyval/dist/idb-keyval.mjs","service-workers.js"],"names":["Store","constructor","dbName","storeName","_dbp","Promise","resolve","reject","openreq","indexedDB","open","onerror","error","onsuccess","result","onupgradeneeded","createObjectStore","_withIDBStore","type","callback","then","db","transaction","oncomplete","onabort","objectStore","store","getDefaultStore","get","key","req","set","value","put","del","delete","clear","keys","openKeyCursor","openCursor","call","push","continue","ZUSAM_VERSION","CACHE_VERSION","CACHE","cache_store","cached_routes","fromNetwork","request","addToCache","fetch","response","responseClone","clone","caches","cache","fromCache","match","matching","update","url","Date","now","_","self","addEventListener","evt","method","Object","some","r","includes","respondWith","waitUntil","hasOwnProperty","lastUsed","find","catch"],"mappings":"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","file":"service-workers.js","sourceRoot":"../src","sourcesContent":["class Store {\r\n    constructor(dbName = 'keyval-store', storeName = 'keyval') {\r\n        this.storeName = storeName;\r\n        this._dbp = new Promise((resolve, reject) => {\r\n            const openreq = indexedDB.open(dbName, 1);\r\n            openreq.onerror = () => reject(openreq.error);\r\n            openreq.onsuccess = () => resolve(openreq.result);\r\n            // First time setup: create an empty object store\r\n            openreq.onupgradeneeded = () => {\r\n                openreq.result.createObjectStore(storeName);\r\n            };\r\n        });\r\n    }\r\n    _withIDBStore(type, callback) {\r\n        return this._dbp.then(db => new Promise((resolve, reject) => {\r\n            const transaction = db.transaction(this.storeName, type);\r\n            transaction.oncomplete = () => resolve();\r\n            transaction.onabort = transaction.onerror = () => reject(transaction.error);\r\n            callback(transaction.objectStore(this.storeName));\r\n        }));\r\n    }\r\n}\r\nlet store;\r\nfunction getDefaultStore() {\r\n    if (!store)\r\n        store = new Store();\r\n    return store;\r\n}\r\nfunction get(key, store = getDefaultStore()) {\r\n    let req;\r\n    return store._withIDBStore('readonly', store => {\r\n        req = store.get(key);\r\n    }).then(() => req.result);\r\n}\r\nfunction set(key, value, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.put(value, key);\r\n    });\r\n}\r\nfunction del(key, store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.delete(key);\r\n    });\r\n}\r\nfunction clear(store = getDefaultStore()) {\r\n    return store._withIDBStore('readwrite', store => {\r\n        store.clear();\r\n    });\r\n}\r\nfunction keys(store = getDefaultStore()) {\r\n    const keys = [];\r\n    return store._withIDBStore('readonly', store => {\r\n        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.\r\n        // And openKeyCursor isn't supported by Safari.\r\n        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {\r\n            if (!this.result)\r\n                return;\r\n            keys.push(this.result.key);\r\n            this.result.continue();\r\n        };\r\n    }).then(() => keys);\r\n}\n\nexport { Store, get, set, del, clear, keys };\n","import { Store, set, get } from 'idb-keyval';\n\nconst ZUSAM_VERSION = '4.1';\nconst CACHE_VERSION = '0.2';\nconst CACHE = 'zusam-' + ZUSAM_VERSION + '-simplecache-' + CACHE_VERSION;\nconst cache_store = new Store('zusam-'+ZUSAM_VERSION, CACHE);\nconst cached_routes = {\n  '/api/users/': 1000 * 60 * 60 * 24, // 24h\n  '/api/images/crop/': null,\n  '/api/images/thumbnail/': null,\n  '/api/links/by_url?': null,\n};\n\n// On fetch, use cache but update the entry with the latest contents\n// from the server.\nself.addEventListener('fetch', function(evt) {\n  if (evt.request.method == \"GET\") {\n\n    // cache-update routes: retrieve from cache and update in background\n    if (Object.keys(cached_routes).some(r => evt.request.url.includes(r))) {\n      // You can use `respondWith()` to answer immediately, without waiting for the\n      // network response to reach the service worker...\n      evt.respondWith(fromCache(evt.request));\n\n      // ...and `waitUntil()` to prevent the worker from being killed until the function is finished.\n      evt.waitUntil(_ => {\n        get(evt.request.url, cache_store).then(r => {\n          if (r && r.hasOwnProperty(\"lastUsed\")) {\n            const timeout = r.lastUsed + cached_routes[Object.keys(cached_routes).find(r => evt.request.url.includes(r))];\n            // update the cache only if the timeout is reached\n            if (timeout < Date.now()) {\n              update(evt.request)\n            }\n          }\n        }).catch(_ => update(evt.request));\n      });\n    } else {\n      // from-network without cache is the default\n      return fromNetwork(evt.request, false);\n    }\n  }\n});\n\n// Make a network request, return the result and add it to cache if asked\nfunction fromNetwork(request, addToCache) {\n    return fetch(request).then(function (response) {\n      if (addToCache) {\n        // response may be used only once\n        // we need to save clone to put one copy in cache\n        // and serve second one\n        let responseClone = response.clone();\n        caches.open(CACHE).then(function (cache) {\n          addToCache(request, responseClone);\n        });\n      }\n      return response;\n    });\n}\n\n// Open the cache where the assets were stored and search for the requested\n// resource. Notice that in case of no matching, the promise still resolves\n// but it does with `undefined` as value.\nfunction fromCache(request) {\n  return caches.open(CACHE).then(function (cache) {\n    return cache.match(request).then(function (matching) {\n      // if nothing matches, return response from network\n      return matching || fromNetwork(request, true);\n    });\n  });\n}\n\n// Update consists in opening the cache, performing a network request and\n// storing the new response data.\nfunction update(request) {\n  return caches.open(CACHE).then(function (cache) {\n    return fetch(request).then(function (response) {\n      return addToCache(request, response);\n    });\n  });\n}\n\n// Add response to cache and store the lastUsed timestamp at the same time\nfunction addToCache(request, response) {\n  return set(request.url, {\n    'lastUsed': Date.now(),\n  }, cache_store).then(_ => cache.put(request, response));\n}\n"]}